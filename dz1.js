/*
1) Подробно прочитать про метод запроса OPTIONS и кратко его описать: когда вызывается, где используется, что передает и принимает.

Метод OPTIONS может быть использован клиентом для определения параметров или требований,
связанных с ресурсом. 
Сервер также может отправлять документацию в удобочитаемом формате.
Коротко о методе:

--безопасный
--идемпотентный(не должен иметь никаких побочных эффектов, кроме сбора статистики или подобных операций.)
--некешируемый
--запрос не имеет тела
--успешный ответ имеет тело.
Использается в качестве предварительного запроса (CORS), помогая браузеру узнать, можно ли осуществить запрос до его обработки.
**CORS-cовместное использование ресурсов между источниками.Это механизм на основе HTTP- заголовка, 
который позволяет серверу указывать любые источники (домен, схему или порт), отличные от его собственных,
из которых браузер должен разрешать загрузку ресурсов.

2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0


Основной особенностью является переход на QUIC(QUIC — это универсальный транспортный протокол).До этого использовался TCP.
Улучшения:

--глубоко зашифрован по умолчанию
--запросы/ответы передаются параллельно(не приводит к задержке)
--соединения могут дольше оставаться активными и сохраняться после смены сети с помощью идентификатора соединения CID

3) Прочитать про способы отмены запроса, включая объект "AbortController"

Интерфейс AbortController позволяет при необходимости обрывать один и более DOM запросов.

3*) Написать по 2 примера создания примитивных значений 
(если есть несколько способов - использовать): 
string, number, boolean, null, undefined, symbol, bigInt.*/

//--string:
const str1 = "2"; // '2'
const str2 = +"2"; // '2'

//--number:
const num1 = 1; // 1
const num2 = Number(2); // 2

//--boolean:
const bool1 = true; // true
const bool2 = Boolean(""); // false

//--null:
const n1 = null; // null

//--undefined:
const undef1 = undefined; // undefined
let undef2; // undefined

//--symbol:
const sym1 = Symbol("key"); //Symbol('key')

//--bigInt:
const bI = 10n; // 10n
const bI2 = BigInt(10); // 10n
/*
4) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError? 

Т.к переменная будет в "мертвой зоне" и не видна интерпретатору до момента объявления.*/

//5)Решить:

const res = "B" + "a" + (1 - "hello");
console.log(res); //'BaNaN'

const res2 = (true && 3) + "d";
console.log(res2); //'3d'

const res3 = Boolean(true && 3) + "d";
console.log(res3); //'trued'
